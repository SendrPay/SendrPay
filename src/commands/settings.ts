import { BotContext } from "../types/bot";
import { prisma } from "../infra/prisma";
import { getWalletBalance } from "../core/wallets";

export async function commandSettings(ctx: BotContext) {
  const userId = ctx.from?.id.toString();
  if (!userId) {
    return ctx.reply("‚ùå Could not identify user.");
  }

  const user = await prisma.user.findUnique({
    where: { telegramId: userId },
    include: { wallets: { where: { isActive: true } } }
  });

  if (!user) {
    return ctx.reply("‚ùå Please start the bot first with /start");
  }

  const settingsMenu = {
    reply_markup: {
      inline_keyboard: [
        [
          { text: "üè† Home", callback_data: "home" },
          { text: "üí∞ My Wallet", callback_data: "wallet" }
        ],
        [
          { text: "üí∏ Send Payment", callback_data: "send_payment" },
          { text: "üéÅ Receive Payment", callback_data: "receive_payment" }
        ],
        [
          { text: "üîí Security Settings", callback_data: "security" },
          { text: "üìä Transaction History", callback_data: "history" }
        ],
        [
          { text: "‚ùì Help & Support", callback_data: "help" },
          { text: "‚öôÔ∏è Bot Settings", callback_data: "bot_settings" }
        ]
      ]
    }
  };

  return ctx.reply("‚öôÔ∏è **Settings Menu**\n\nChoose an option:", {
    parse_mode: "Markdown",
    ...settingsMenu
  });
}

export async function handleSettingsCallback(ctx: BotContext) {
  const data = ctx.callbackQuery?.data;
  if (!data) return;

  const userId = ctx.from?.id.toString();
  if (!userId) return;

  switch (data) {
    case "home":
      return showHomePage(ctx);
    case "wallet":
      return showWalletInfo(ctx);
    case "send_payment":
      return showSendPayment(ctx);
    case "receive_payment":
      return showReceivePayment(ctx);
    case "security":
      return showSecuritySettings(ctx);
    case "history":
      return showTransactionHistory(ctx);
    case "help":
      return showHelp(ctx);
    case "bot_settings":
      return showBotSettings(ctx);
  }
}

export async function showHomePage(ctx: BotContext) {
  const userId = ctx.from?.id.toString();
  if (!userId) return;

  const user = await prisma.user.findUnique({
    where: { telegramId: userId },
    include: { wallets: { where: { isActive: true } } }
  });

  if (!user || !user.wallets[0]) {
    const welcomeMenu = {
      reply_markup: {
        inline_keyboard: [
          [{ text: "üîê Generate Wallet", callback_data: "generate_wallet" }],
          [{ text: "üì• Import Private Key", callback_data: "import_wallet" }]
        ]
      }
    };

    return ctx.editMessageText(`üöÄ **Welcome to Solana Pay Bot!**

**Features:**
‚Ä¢ üéÅ Create giveaways
‚Ä¢ üí∞ Escrow for non-users  
‚Ä¢ üîí Secure encrypted wallet storage

**Terms of Service:**
By using this bot, you agree to:
‚Ä¢ Use only legitimate funds
‚Ä¢ Understand blockchain risks
‚Ä¢ Take responsibility for your wallet security

**Choose an option to get started:**`, {
      parse_mode: "Markdown",
      ...welcomeMenu
    });
  }

  // Get wallet balance
  const wallet = user.wallets[0];
  const balances = await getWalletBalance(wallet.address);
  
  let balanceText = "üí∞ **Your Balances:**\n";
  if (balances && balances.length > 0) {
    balances.forEach(balance => {
      balanceText += `‚Ä¢ ${balance.formatted} ${balance.token}\n`;
    });
  } else {
    balanceText += "No tokens found\n";
  }

  const homeMenu = {
    reply_markup: {
      inline_keyboard: [
        [
          { text: "üí∏ Send Payment", callback_data: "send_payment" },
          { text: "üéÅ Receive", callback_data: "receive_payment" }
        ],
        [
          { text: "üìä History", callback_data: "history" },
          { text: "‚öôÔ∏è Settings", callback_data: "settings_main" }
        ]
      ]
    }
  };

  const homeText = `üè† **Home** - @${user.handle || 'No username'}

${balanceText}

üè¶ **Wallet Address:**
\`${wallet.address}\`

**How to use:**
‚Ä¢ **In Groups:** Reply to messages with /tip or /pay
‚Ä¢ **In DMs:** Use /pay @username amount TOKEN
‚Ä¢ **Giveaways:** Use /giveaway in groups
‚Ä¢ **Split Bills:** Use /split amount TOKEN @user1 @user2

Ready to make payments!`;

  return ctx.editMessageText(homeText, {
    parse_mode: "Markdown",
    ...homeMenu
  });
}

async function showWalletInfo(ctx: BotContext) {
  const userId = ctx.from?.id.toString();
  if (!userId) return;

  const user = await prisma.user.findUnique({
    where: { telegramId: userId },
    include: { wallets: { where: { isActive: true } } }
  });

  if (!user || !user.wallets[0]) {
    return ctx.editMessageText("‚ùå No wallet found. Please create one first.");
  }

  const wallet = user.wallets[0];
  const balances = await getWalletBalance(wallet.address);
  
  let balanceText = "üí∞ **Current Balances:**\n\n";
  if (balances && balances.length > 0) {
    balances.forEach(balance => {
      balanceText += `${balance.token}: ${balance.formatted}\n`;
    });
  } else {
    balanceText += "No tokens found";
  }

  const walletMenu = {
    reply_markup: {
      inline_keyboard: [
        [{ text: "üîÑ Refresh Balance", callback_data: "wallet" }],
        [{ text: "üè† Back to Home", callback_data: "home" }]
      ]
    }
  };

  const walletText = `üè¶ **My Wallet**

üìç **Address:**
\`${wallet.address}\`

${balanceText}

**Wallet Type:** ${wallet.label}
**Status:** Active ‚úÖ`;

  return ctx.editMessageText(walletText, {
    parse_mode: "Markdown",
    ...walletMenu
  });
}

async function showSendPayment(ctx: BotContext) {
  const sendMenu = {
    reply_markup: {
      inline_keyboard: [
        [{ text: "üí≥ Quick Pay", callback_data: "quick_pay" }],
        [{ text: "üè† Back to Home", callback_data: "home" }]
      ]
    }
  };

  const sendText = `üí∏ **Send Payment**

**How to Send:**

**In Groups:**
\`/pay @username 10 USDC\`
\`/tip 5 SOL\` (reply to message)

**In Direct Messages:**
\`/pay @username 25 BONK\`

**Supported Tokens:**
‚Ä¢ SOL (Solana)
‚Ä¢ USDC (USD Coin)  
‚Ä¢ BONK (Bonk)
‚Ä¢ JUP (Jupiter)

**Note:** Recipients must have their Telegram username set and registered with the bot.`;

  return ctx.editMessageText(sendText, {
    parse_mode: "Markdown",
    ...sendMenu
  });
}

async function showReceivePayment(ctx: BotContext) {
  const userId = ctx.from?.id.toString();
  if (!userId) return;

  const user = await prisma.user.findUnique({
    where: { telegramId: userId }
  });

  const receiveMenu = {
    reply_markup: {
      inline_keyboard: [
        [{ text: "üè† Back to Home", callback_data: "home" }]
      ]
    }
  };

  const receiveText = `üéÅ **Receive Payments**

**Your Payment Handle:**
${user?.handle ? `@${user.handle}` : "‚ùå No username set"}

**To receive payments:**
1. Make sure your Telegram username is set
2. Share your handle: @${user?.handle || 'yourusername'}
3. Others can pay you with:
   \`/pay @${user?.handle || 'yourusername'} 10 USDC\`

${!user?.handle ? "‚ö†Ô∏è **Set your Telegram username in Settings > Username to receive payments!**" : "‚úÖ **Ready to receive payments!**"}`;

  return ctx.editMessageText(receiveText, {
    parse_mode: "Markdown",
    ...receiveMenu
  });
}

async function showSecuritySettings(ctx: BotContext) {
  const securityMenu = {
    reply_markup: {
      inline_keyboard: [
        [{ text: "üîë Export Private Key", callback_data: "export_key" }],
        [{ text: "üóëÔ∏è Delete Wallet", callback_data: "delete_wallet" }],
        [{ text: "üè† Back to Home", callback_data: "home" }]
      ]
    }
  };

  const securityText = `üîí **Security Settings**

**Wallet Security:**
‚Ä¢ Your private key is encrypted with AES-256-GCM
‚Ä¢ Keys are stored securely in encrypted database
‚Ä¢ Only you have access to your wallet

**Important Reminders:**
‚Ä¢ Never share your private key
‚Ä¢ Keep backups secure
‚Ä¢ Bot runs on Solana devnet (test network)
‚Ä¢ Always verify recipient addresses`;

  return ctx.editMessageText(securityText, {
    parse_mode: "Markdown",
    ...securityMenu
  });
}

async function showTransactionHistory(ctx: BotContext) {
  const userId = ctx.from?.id.toString();
  if (!userId) return;

  const user = await prisma.user.findUnique({
    where: { telegramId: userId }
  });

  if (!user) {
    return ctx.editMessageText("‚ùå User not found.");
  }

  const payments = await prisma.payment.findMany({
    where: {
      OR: [
        { fromUserId: user.id },
        { toUserId: user.id }
      ]
    },
    orderBy: { createdAt: 'desc' },
    take: 10,
    include: {
      fromUser: true,
      toUser: true
    }
  });

  let historyText = "üìä **Transaction History** (Last 10)\n\n";
  
  if (payments.length === 0) {
    historyText += "No transactions yet.";
  } else {
    payments.forEach((payment, index) => {
      const isSent = payment.fromUserId === user.id;
      const direction = isSent ? "‚Üí" : "‚Üê";
      const otherUser = isSent ? payment.toUser : payment.fromUser;
      const amount = parseFloat(payment.amountRaw) / Math.pow(10, 6); // Assuming 6 decimals for display
      
      historyText += `${index + 1}. ${direction} ${amount.toFixed(2)} ${payment.tokenTicker}\n`;
      historyText += `   ${isSent ? 'To' : 'From'}: @${otherUser?.handle || 'Unknown'}\n`;
      historyText += `   ${payment.status} ‚Ä¢ ${payment.createdAt.toLocaleDateString()}\n\n`;
    });
  }

  const historyMenu = {
    reply_markup: {
      inline_keyboard: [
        [{ text: "üè† Back to Home", callback_data: "home" }]
      ]
    }
  };

  return ctx.editMessageText(historyText, {
    parse_mode: "Markdown",
    ...historyMenu
  });
}

async function showHelp(ctx: BotContext) {
  const helpMenu = {
    reply_markup: {
      inline_keyboard: [
        [{ text: "üè† Back to Home", callback_data: "home" }]
      ]
    }
  };

  const helpText = `‚ùì **Help & Support**

**Basic Commands:**
‚Ä¢ \`/start\` - Start the bot
‚Ä¢ \`/wallet\` - Show wallet info
‚Ä¢ \`/pay @user amount TOKEN\` - Send payment
‚Ä¢ \`/tip amount TOKEN\` - Tip (reply to message)
‚Ä¢ \`/balance\` - Check balance

**Group Commands:**
‚Ä¢ \`/enable\` - Enable bot (admins only)
‚Ä¢ \`/giveaway amount TOKEN\` - Create giveaway
‚Ä¢ \`/split 100 USDC @user1 @user2\` - Split bill

**Support:**
‚Ä¢ Bot runs on Solana devnet (test network)
‚Ä¢ Transactions are real but on test network
‚Ä¢ Report issues to bot administrator
‚Ä¢ Keep your private keys secure

**Need Help?**
Contact the bot administrator or check our documentation.`;

  return ctx.editMessageText(helpText, {
    parse_mode: "Markdown",
    ...helpMenu
  });
}

async function showBotSettings(ctx: BotContext) {
  const settingsMenu = {
    reply_markup: {
      inline_keyboard: [
        [{ text: "üîî Notifications", callback_data: "notifications" }],
        [{ text: "üåê Language", callback_data: "language" }],
        [{ text: "üè† Back to Home", callback_data: "home" }]
      ]
    }
  };

  const settingsText = `‚öôÔ∏è **Bot Settings**

**Current Settings:**
‚Ä¢ Notifications: On ‚úÖ
‚Ä¢ Language: English üá∫üá∏
‚Ä¢ Network: Solana Devnet
‚Ä¢ Version: 1.0.0

**Features:**
‚Ä¢ Real-time balance updates
‚Ä¢ Transaction confirmations
‚Ä¢ Security notifications
‚Ä¢ Multi-token support`;

  return ctx.editMessageText(settingsText, {
    parse_mode: "Markdown",
    ...settingsMenu
  });
}